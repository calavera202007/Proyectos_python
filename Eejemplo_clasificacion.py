# -*- coding: utf-8 -*-
"""clasificacion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FY0Y-HKdEbJjqm5j-cqxbg71--YR3qH5
"""

user1 = [5,2]

user2 = [1,5]

"""Distancia de minkowski para dos conjuntos de datos"""

def distancia_minkowski(p1, p2, p):

  # Calcula la distancia entre cada coordenada de los dos puntos.

  diferencias = [abs(p1[i] - p2[i]) ** p for i in range(len(p1))]

  # Devuelve la raíz de la suma de las distancias de las coordenadas.

  return (sum(diferencias) ** (1 / p))

distancia_minkowski(user1,user2,1)

def distancia(p1,p2,p):
  resultado =0;
  for i in range(len(p1)):
    resultado=resultado+(abs(p1[i]-p2[i]))**p

  return(resultado**(1/p))

distancia(user1,user2,1)

"""litas"""

import pathlib



con=[]
def read_file(file):
  # Abrir el archivo y leer su contenido.
  with file.open() as f:
   contenido = f.readlines()
  # Imprimir el contenido del archivo.
  return(contenido)
con=read_file(path)

path = pathlib.Path("/content/tableConvert.com_7bv0cd.csv")
read_file(path)

def dividir_datos(X, y, porcentaje_prueba):
  """
  Divide el conjunto de datos en un conjunto de entrenamiento y un conjunto de prueba.

  Args:
    X: Las características de los datos.
    y: Las etiquetas de los datos.
    porcentaje_prueba: El porcentaje de datos que se utilizará para la prueba.

  Returns:
    Los conjuntos de entrenamiento y prueba.
  """

  # Obtener el número de datos
  n_datos = len(X)

  # Obtener el número de datos de prueba
  n_datos_prueba = int(porcentaje_prueba * n_datos)

  # Seleccionar los índices de los datos de prueba
  indices_prueba = np.random.choice(n_datos, size=n_datos_prueba, replace=False)

  # Seleccionar los datos de prueba
  X_prueba = X[indices_prueba]
  y_prueba = y[indices_prueba]

  # Seleccionar los índices de los datos de entrenamiento
  indices_entrenamiento = np.array([i for i in range(n_datos) if i not in indices_prueba])

  # Seleccionar los datos de entrenamiento
  X_entrenamiento = X[indices_entrenamiento]
  y_entrenamiento = y[indices_entrenamiento]

  # Devolver los conjuntos de entrenamiento y prueba
  return X_entrenamiento, y_entrenamiento, X_prueba, y_prueba

dividir_datos

"""Separar en dos la lista, entrenamiento y test"""

import random

entrenamiento = []
train_set = []
test_set = []

def division(datos):

  random.shuffle(datos)
  n_entrenamiento = int(0.7 * len(datos))

  # Dividir los datos en dos partes.
  entrenamiento = datos[:n_entrenamiento]
  prueba = datos[n_entrenamiento:]
  return()

print(entrenamiento)

test_set = train_set[1]

def clasificar(muestra,entre,k):
  return(distancia(muestra,entre,2))

"""Usando Numpy"""

import numpy as np
import pandas as pd

# Leer el dataset Iris
df_iris = pd.read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data", header=None)

# Obtener las características de los datos
X = df_iris.iloc[:, :-1].values

# Obtener las etiquetas de los datos
y = df_iris.iloc[:, -1].values

# Definir la función de distancia de Minkowski
def minkowski_distance(x1, x2, p=2):
  """
  Calcula la distancia de Minkowski entre dos vectores.

  Args:
    x1: El primer vector.
    x2: El segundo vector.
    p: El exponente de la distancia de Minkowski.

  Returns:
    La distancia de Minkowski entre los dos vectores.
  """

  return np.linalg.norm(x1 - x2, p)
k=5
# Calcular las distancias entre todos los puntos
distancias = np.zeros((X.shape[0], X.shape[0]))
for i in range(X.shape[0]):
  for j in range(X.shape[0]):
    distancias[i, j] = minkowski_distance(X[i], X[j])

# Clasificar los datos utilizando la distancia de Minkowski

etiquetas_clasificadas = np.argmin(distancias, axis=1)
# Ordenar las distancias de menor a mayor
distancias_ordenadas = np.argsort(distancias)

# Obtener los k vecinos más cercanos
vecinos_mas_cercanos = distancias_ordenadas[:k]
# Obtener las etiquetas de los k vecinos más cercanos
etiquetas_vecinos = y[vecinos_mas_cercanos]
# Imprimir las etiquetas clasificadas
print(etiquetas_vecinos,vecinos_mas_cercanos)