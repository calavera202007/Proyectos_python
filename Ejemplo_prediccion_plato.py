# -*- coding: utf-8 -*-
"""Prediccion_plato.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dCTp6ViZDvSl9Vqiv-8Lyt5TB5SDbO6M
"""

#Jeisson David Infante Leal
#Andres Felipe Porras Garzon

import csv

# Especifica la ruta de tu archivo CSV y la codificación adecuada
archivo_csv = '/content/usuarios.csv'
codificacion = 'ISO-8859-1'  # Cambia esto según la codificación real de tu archivo

# Abre el archivo en modo lectura con la codificación especificada
with open(archivo_csv, 'r', encoding=codificacion) as archivo:
    # Crea un objeto lector de CSV
    lector_csv = csv.reader(archivo)

    # Itera sobre las filas del archivo
    for fila in lector_csv:
        # Cada fila es una lista de valores, puedes acceder a los valores por índice
        print(fila)

# Especifica la ruta de tu archivo CSV y la codificación adecuada
archivo_csv = '/content/usuarios.csv'
codificacion = 'ISO-8859-1'  # Cambia esto según la codificación real de tu archivo

# Abre el archivo en modo lectura con la codificación especificada
with open(archivo_csv, 'r', encoding=codificacion) as archivo:
    # Crea un objeto lector de CSV
    lector_csv = csv.reader(archivo)

    # Lee todas las filas del archivo en una lista
    filas = list(lector_csv)

# Encuentra y guarda las filas únicas basándote en la primera columna (cambia el índice si la columna es diferente)
filas_unicas = [filas[0]] + [fila for i, fila in enumerate(filas[1:], 1) if fila[0] not in [f[0] for f in filas[:i]]]

# Imprime las filas únicas
for fila in filas_unicas:
    print(fila)

import csv
import random

# Función para inicializar centroides aleatorios
def inicializar_centroides(datos, k):
    return [{"visitas": random.choice(datos)["visitas"]} for _ in range(k)]

def asignar_clusters(datos, centroides):
    clusters = [[] for _ in range(len(centroides))]
    for cliente in datos:
        # Accede directamente al valor de visitas
        distancias = [abs(cliente["visitas"] - c["visitas"]) for c in centroides]
        cluster_asignado = distancias.index(min(distancias))
        clusters[cluster_asignado].append(cliente)
    return clusters

# Función para actualizar centroides
def actualizar_centroides(clusters):
    nuevos_centroides = []
    for cluster in clusters:
        if len(cluster) > 0:
            promedio_visitas = sum(cliente["visitas"] for cliente in cluster) / len(cluster)
            nuevos_centroides.append({"visitas": promedio_visitas})
    return nuevos_centroides

# Función principal del algoritmo de K-Means
def k_means(datos, k, iteraciones):
    centroides = inicializar_centroides(datos, k)

    for _ in range(iteraciones):
        clusters = asignar_clusters(datos, centroides)
        centroides = actualizar_centroides(clusters)

    return clusters

# Especifica la ruta de tu archivo CSV y la codificación adecuada
archivo_csv = '/content/usuarios.csv'
codificacion = 'ISO-8859-1'  # Cambia esto según la codificación real de tu archivo

# Lista para almacenar los datos del CSV
clientes = []

# Abre el archivo en modo lectura con la codificación especificada
with open(archivo_csv, 'r', encoding=codificacion) as archivo:
    # Crea un objeto lector de CSV
    lector_csv = csv.reader(archivo, delimiter=';')

    # Saltar la primera línea que contiene los encabezados
    next(lector_csv)

    # Itera sobre las filas del archivo
    for fila in lector_csv:
        nombre = fila[0]
        visitas = int(fila[1])
        cliente = {"nombre": nombre, "visitas": visitas}
        clientes.append(cliente)

# Parámetros del modelo
k = 20  # Número de clusters
iteraciones = 10  # Número de iteraciones del algoritmo

# Ejecutar el algoritmo
resultados = k_means(clientes, k, iteraciones)

# Imprimir resultados
for i, cluster in enumerate(resultados):
    print(f"Cluster {i+1}: {len(cluster)} clientes")
    for cliente in cluster:
        print(f"  - {cliente['nombre']}")
    print("\n")

import csv
import random

# Función para normalizar los datos
def normalizar(datos):
    max_valor_visitas = max(datos, key=lambda x: x["visitas"])["visitas"]
    for cliente in datos:
        cliente["visitas"] /= max_valor_visitas

# Función para inicializar centroides aleatorios
def inicializar_centroides(datos, k):
    return random.sample(datos, k)

# Función para asignar clientes a clusters basado en platos favoritos
def asignar_clusters_por_platos(datos, centroides):
    clusters = [[] for _ in range(len(centroides))]
    for cliente in datos:
        distancias = [len(set(cliente["platos_favoritos"]) & set(c["platos_favoritos"])) for c in centroides]
        cluster_asignado = distancias.index(max(distancias))
        clusters[cluster_asignado].append(cliente)
    return clusters

# Función para actualizar centroides
def actualizar_centroides_por_platos(clusters):
    nuevos_centroides = []
    for cluster in clusters:
        if len(cluster) > 0:
            # Calcular el plato favorito más común en el cluster
            platos_favoritos_comunes = max(set(plato for cliente in cluster for plato in cliente["platos_favoritos"]), key=lambda x: sum(x in cliente["platos_favoritos"] for cliente in cluster))
            nuevos_centroides.append({"platos_favoritos": [platos_favoritos_comunes]})
    return nuevos_centroides

# Función principal del algoritmo de K-Means basado en platos favoritos
def k_means_por_platos(datos, k, iteraciones):
    centroides = inicializar_centroides(datos, k)

    for _ in range(iteraciones):
        clusters = asignar_clusters_por_platos(datos, centroides)
        centroides = actualizar_centroides_por_platos(clusters)

    return clusters

# Especifica la ruta de tu archivo CSV y la codificación adecuada
archivo_csv = '/content/usuarios.csv'
codificacion = 'ISO-8859-1'  # Cambia esto según la codificación real de tu archivo

# Lista para almacenar los datos del CSV
clientes = []

# Abre el archivo en modo lectura con la codificación especificada
with open(archivo_csv, 'r', encoding=codificacion) as archivo:
    # Crea un objeto lector de CSV
    lector_csv = csv.reader(archivo, delimiter=';')

    # Saltar la primera línea que contiene los encabezados
    next(lector_csv)

    # Itera sobre las filas del archivo
    for fila in lector_csv:
        nombre = fila[0]
        visitas = int(fila[1])
        platos_favoritos = [plato.strip("'").strip() for plato in fila[3].strip('[]').split(',')]
        cliente = {"nombre": nombre, "visitas": visitas, "platos_favoritos": platos_favoritos}
        clientes.append(cliente)

# Normalizar los datos
normalizar(clientes)

# Parámetros del modelo
k = 30  # Número de clusters
iteraciones = 10  # Número de iteraciones del algoritmo

# Ejecutar el algoritmo
resultados = k_means_por_platos(clientes, k, iteraciones)

# Imprimir resultados
for i, cluster in enumerate(resultados):
    print(f"Cluster {i+1}: {len(cluster)} clientes")
    for cliente in cluster:
        print(f"  - {cliente['nombre']}")
    print("\n")

import csv
import random

# Función para normalizar los datos
def normalizar(datos):
    max_valor_visitas = max(datos, key=lambda x: x["visitas"])["visitas"]
    for cliente in datos:
        cliente["visitas"] /= max_valor_visitas

# Función para inicializar centroides aleatorios
def inicializar_centroides(datos, k):
    return random.sample(datos, k)

# Función para asignar clientes a clusters basado en platos favoritos
def asignar_clusters_por_platos(datos, centroides):
    clusters = [[] for _ in range(len(centroides))]
    for cliente in datos:
        distancias = [len(set(cliente["platos_favoritos"]) & set(c["platos_favoritos"])) for c in centroides]
        cluster_asignado = distancias.index(max(distancias))
        clusters[cluster_asignado].append(cliente)
    return clusters

# Función para actualizar centroides
def actualizar_centroides_por_platos(clusters):
    nuevos_centroides = []
    for cluster in clusters:
        if len(cluster) > 0:
            # Calcular el plato favorito más común en el cluster
            platos_favoritos_comunes = max(set(plato for cliente in cluster for plato in cliente["platos_favoritos"]), key=lambda x: sum(x in cliente["platos_favoritos"] for cliente in cluster))
            nuevos_centroides.append({"platos_favoritos": [platos_favoritos_comunes]})
    return nuevos_centroides

# Función principal del algoritmo de K-Means basado en platos favoritos
def k_means_por_platos(datos, k, iteraciones):
    centroides = inicializar_centroides(datos, k)

    for _ in range(iteraciones):
        clusters = asignar_clusters_por_platos(datos, centroides)
        centroides = actualizar_centroides_por_platos(clusters)

    return clusters

# Función para agregar una nueva tupla
def agregar_tupla():
    nuevo_nombre = input("Ingrese el nombre del cliente (o 'salir' para terminar): ")

    if nuevo_nombre.lower() == 'salir':
        return None

    nuevo_visitas = int(input("Ingrese el número de visitas: "))
    nuevo_platos = input("Ingrese los platos favoritos separados por comas: ").split(',')

    # Crear el nuevo cliente y retornarlo
    nuevo_cliente = {"nombre": nuevo_nombre, "visitas": nuevo_visitas, "platos_favoritos": nuevo_platos}
    return nuevo_cliente

# Especifica la ruta de tu archivo CSV y la codificación adecuada
archivo_csv = '/content/usuarios.csv'
codificacion = 'ISO-8859-1'  # Cambia esto según la codificación real de tu archivo La elección de la codificación dependerá del
                              #contenido real del archivo. Si estás trabajando con archivos CSV y encuentras problemas de codificación, puedes probar diferentes codificaciones como UTF-8, UTF-16, Latin-1, etc.

# Lista para almacenar los datos del CSV
clientes = []

# Abre el archivo en modo lectura con la codificación especificada
with open(archivo_csv, 'r', encoding=codificacion) as archivo:
    # Crea un objeto lector de CSV
    lector_csv = csv.reader(archivo, delimiter=';')

    # Saltar la primera línea que contiene los encabezados
    next(lector_csv)

    # Itera sobre las filas del archivo
    for fila in lector_csv:
        nombre = fila[0]
        visitas = int(fila[1])
        platos_favoritos = [plato.strip("'").strip() for plato in fila[3].strip('[]').split(',')]
        cliente = {"nombre": nombre, "visitas": visitas, "platos_favoritos": platos_favoritos}
        clientes.append(cliente)

# Normalizar los datos
normalizar(clientes)

# Parámetros del modelo
k = 40  # Número de clusters
iteraciones = 10  # Número de iteraciones del algoritmo

# Ejecutar el algoritmo
resultados = k_means_por_platos(clientes, k, iteraciones)

# Imprimir resultados
for i, cluster in enumerate(resultados):
    print(f"Cluster {i+1}: {len(cluster)} clientes")
    for cliente in cluster:
        print(f"  - {cliente['nombre']}")
    print("\n")

# Solicitar nueva tupla al usuario y actualizar los resultados0
while True:
    nuevo_cliente = agregar_tupla()

    if nuevo_cliente is None:
        break

    clientes.append(nuevo_cliente)

    # Normalizar los datos con la nueva tupla
    normalizar(clientes)

    # Ejecutar el algoritmo nuevamente con los nuevos datos
    resultados = k_means_por_platos(clientes, k, iteraciones)

    # Imprimir resultados actualizados
    for i, cluster in enumerate(resultados):
        print(f"Cluster {i+1}: {len(cluster)} clientes")
        for cliente in cluster:
            print(f"  - {cliente['nombre']}")
        print("\n")
#

# Ejecutar el algoritmo
resultados = k_means_por_platos(clientes, k, iteraciones)

# Visualizar los resultados
for i, cluster in enumerate(resultados):
    print(f"Cluster {i+1}: {len(cluster)} clientes")

    # Contar manualmente la frecuencia de los platos favoritos en el cluster
    frecuencia_platos = {}
    for cliente in cluster:
        for plato in cliente['platos_favoritos']:
            if plato in frecuencia_platos:
                frecuencia_platos[plato] += 1
            else:
                frecuencia_platos[plato] = 1

    # Mostrar los platos favoritos más comunes en el cluster
    platos_comunes = sorted(frecuencia_platos.items(), key=lambda x: x[1], reverse=True)[:5]
    print(f"Platos favoritos más comunes:")
    for plato, frecuencia in platos_comunes:
        print(f"  - {plato}: {frecuencia} veces")

    print("\n")

#si se deseara recomendar un nuevo plato segun las preferencias de todos los grupos o de cada cluster se podria usar los platos favoritos mas comunes que comparten en
#cada cluster para hacer una sugerencia siendo la mas comun la que mas gusto tiene y la que por ende si es pizza o pasta se podria recomendar un nuevo plato
#o dependiendo los tipos de pizza o pasta mas comun se podria recomendar en base a esto

"""El numero de cluster son las posibles clasificaciones en base a las comidas favoritas que ayudan a la creacion de mis centroides. no es la division maxima de clubsters que se puede hacer dentro del programa pero el resultado es el mas adecuado y genera valor.

Utilizamos una nuevo data para ver la clasificacion del programa, dependiendo la eleccion de los platos asi mismo se dara la clasificacion del cluster, para determinar la eficacia del programa.
"""